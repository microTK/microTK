// Generated by CoffeeScript 1.10.0

/**
  * microTK - v0.0.2
  *
  * @author Todd Henderson <todd@todd-henderson.me>
  * @license The MIT License (MIT)
  *
  * Copyright (c) 2014-2016 Todd Henderson
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
  * in the Software without restriction, including without limitation the rights
  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the Software is
  * furnished to do so, subject to the following conditions:
  *
  * The above copyright notice and this permission notice shall be included in all
  * copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  *
 */


/**
  * This action is triggered when the conditions are met.
  * 
  * @callback elementAction
  * @param {HTMLElement} element
 */

(function() {
  var MicroTK, root,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  MicroTK = (function() {
    function MicroTK(_selector, _scope) {
      var _node, _nodelist, i, j, k, key, len, len1, len2, node;
      if (_scope == null) {
        _scope = root.document;
      }
      this.length = 0;
      if (!_selector) {
        return;
      }
      if (typeof result === 'string') {
        _selector = _selector.trim();
      }
      if (_selector instanceof Element) {
        this[0] = _selector;
        this.length = 1;
      } else if (_selector.slice(0, _selector.length) === '#' && _selector.indexOf(" " === -1 && _selector.indexOf("." === -1))) {
        _node = _scope.getElementById(_selector.replace(/\#/g, ""));
        if (_node != null) {
          this[0] = _node;
          this.length = 1;
        }
      } else if (_selector.slice(0, _selector.length) === "." && _selector.indexOf("#" === -1 && _selector.indexOf(":" === -1 && _selector.indexOf(" " === -1)))) {
        _nodelist = _scope.getElementsByClassName(_selector.replace(/\./g, " "));
        this.length = 0;
        if (_nodelist != null) {
          for (key = i = 0, len = _nodelist.length; i < len; key = ++i) {
            node = _nodelist[key];
            this[key] = node;
            this.length++;
          }
        }
      } else if (/^[a-zA-Z]+$/.test(_selector)) {
        _nodelist = _scope.getElementsByTagName(_selector);
        this.length = 0;
        if (_nodelist != null) {
          for (key = j = 0, len1 = _nodelist.length; j < len1; key = ++j) {
            node = _nodelist[key];
            this[key] = node;
            this.length++;
          }
        }
      } else {
        _nodelist = _scope.querySelectorAll(_selector);
        this.length = 0;
        if (_nodelist != null) {
          for (key = k = 0, len2 = _nodelist.length; k < len2; key = ++k) {
            node = _nodelist[key];
            this[key] = node;
            this.length++;
          }
        }
      }
    }


    /**
     * Adds an attribute to the selected elements.
     *
     * @param {string} name - The attribute to be added.
     * @param {string} value - The value of the attribute.
     * @returns {MicroTK | } A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.addAttribute = function(name, value) {
      var _element, i, len;
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        _element.setAttribute(name, value);
      }
      return this;
    };


    /**
     * Adds a class to the selected elements.
     *
     * @param {string} className - The class to be added.
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.addClass = function(className) {
      var _element, i, len, ref;
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        if (_element != null) {
          if ((ref = _element.classList) != null) {
            ref.add(className);
          }
        }
      }
      return this;
    };


    /**
     * Adds an event to the selected elements.
     *
     * @param {string} event - Event to be added.
     * @param {function} action - Function to be run on event.
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.addEvent = function(event, action) {
      var _contains, _element, base, i, len, ref;
      _contains = function(object, value) {
        var i, item, len;
        if (object != null) {
          for (i = 0, len = object.length; i < len; i++) {
            item = object[i];
            if (item = value) {
              return true;
            }
          }
        }
        return false;
      };
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        if (!_contains(_element != null ? (ref = _element._mtk) != null ? ref.actions : void 0 : void 0, {
          event: event,
          action: action
        })) {
          if ((_element != null ? _element.addEventListener : void 0) != null) {
            _element.addEventListener(event, action, false);
          } else if ((_element != null ? _element.attachEvent : void 0) != null) {
            _element.attachEvent("on" + event, action);
          } else {
            _element["on" + event] = action;
          }
          if (_element._mtk == null) {
            _element._mtk = {};
          }
          if ((base = _element._mtk).actions == null) {
            base.actions = [];
          }
          _element._mtk.actions.push;
        }
      }
      return this;
    };


    /**
     * Appends an HTMLElement into the selected elements.
     *
     * @param {HTMLElement} element - Element to be removed.
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.append = function(element) {
      var _element, i, len;
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        _element.appendChild(element);
      }
      return this;
    };


    /**
     * Performs an action on the selected elements
     *
     * @param {elementAction} action - Function to be run when the element has providec class.
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.each = function(action) {
      var _element, i, len;
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        action(_element);
      }
      return this;
    };


    /**
     * Checks to see if elements contains provided class and performs provided action.
     *
     * @param {string} name - The attribute to be added.
     * @param {elementAction} action - Function to be run when the element has provided attribute.
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.hasAttribute = function(name, action) {
      var _element, i, len;
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        if (_element.hasAttribute(name)) {
          action(element);
        }
      }
      return this;
    };


    /**
     * Checks to see ff elements contains provided class and performs provided action.
     *
     * @param {string} className - Element to be tested for.
     * @param {elementAction} action - Function to be run when the element has providec class.
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.hasClass = function(className, action) {
      var _element, i, len, ref;
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        if (_element != null ? (ref = _element.classList) != null ? ref.contains(className) : void 0 : void 0) {
          action(element);
        }
      }
      return this;
    };


    /**
     * Prepends an HTMLElement into the selected elements.
     *
     * @param {HTMLElement} element - Element to be removed.
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.prepend = function(elements) {
      var _element, i, len;
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        if (_element.firstChild != null) {
          _element.insertBefore(elements, _element.firstChild);
        } else {
          _element.appendChild(elements);
        }
      }
      return this;
    };


    /**
     * Removes the selected elements from the DOM.
     *
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.remove = function() {
      var _element, i, key, len;
      for (key = i = 0, len = this.length; i < len; key = ++i) {
        _element = this[key];
        if (_element.remove) {
          _element.remove();
          delete this[key];
          this.length--;
        } else {
          _element.parentElement.removeChild(_element);
          delete this[key];
          this.length--;
        }
      }
      return this;
    };


    /**
     * Removes an attribute from the selected elements.
     *
     * @param {string} name - The attribute to be added.
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.removeAttribute = function(name) {
      var _element, i, len, results;
      results = [];
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        results.push(_element.removeAttribute(name));
      }
      return results;
    };


    /**
     * Removes a class from the selected elements.
     *
     * @param {string} className - Class to be removed.
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.removeClass = function(className) {
      var _element, i, len, ref;
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        if (_element != null) {
          if ((ref = _element.classList) != null) {
            ref.remove(className);
          }
        }
      }
      return this;
    };


    /**
     * Removes the id from the selected elements.
     *
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.removeId = function() {
      var _element, i, len;
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        _element.removeAttribute('id');
      }
      return this;
    };


    /**
     * Toggles a class in selected elements.
     *
     * @param {string} className - Class to be toggled.
     * @returns {microTK} A copy of the microTK object.
     * @public
     */

    MicroTK.prototype.toggleClass = function(className) {
      var _element, i, len, ref;
      for (i = 0, len = this.length; i < len; i++) {
        _element = this[i];
        if (_element != null) {
          if ((ref = _element.classList) != null) {
            ref.toggle(className);
          }
        }
      }
      return this;
    };

    return MicroTK;

  })();

  root.MicroTK = MicroTK;

  root.microTK = function(_selector, _scope) {
    return new MicroTK(_selector, _scope);
  };


  /**
   * Recursivly merges objects.
   *
   * @param {Object} object - The destination object.
   * @param {Object} [sourse...] - The sourse objects.
   * @param {errorOnlyCallback} [callback] - Passes an error if one occures. 
   * @returns {Object} Returns the merged destination object.
   * @public
   */

  root.microTK.merge = function() {
    var i, object, source, sources;
    object = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    _merge(function(destination, source) {
      var key, ref, val;
      for (key in source) {
        if (!hasProp.call(source, key)) continue;
        val = source[key];
        if ((val != null ? val.constructor : void 0) === Object && ((ref = destination[key]) != null ? ref.constructor : void 0) === Object) {
          destination[key] = microTK.prototype.merge(destination[key], val);
        } else {
          destination[key] = val;
        }
      }
      return destination;
    });
    if (object == null) {
      object = {};
    }
    for (i = sources.length - 1; i >= 0; i += -1) {
      source = sources[i];
      _merge(object, source);
    }
    return object;
  };

  root.µ = root.microTK;

}).call(this);
